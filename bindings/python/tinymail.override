/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#include <Python.h>
#include <pygobject.h>

#include <tny-error.h>
#include <tny-account.h>
#include <tny-account-store.h>
#include <tny-device.h>
#include <tny-fs-stream.h>
#include <tny-iterator.h>
#include <tny-simple-list.h>
#include <tny-list.h>
#include <tny-folder.h>
#include <tny-header.h>
#include <tny-msg.h>
#include <tny-mime-part.h>
#include <tny-shared.h>
#include <tny-store-account.h>
#include <tny-stream.h>
#include <tny-transport-account.h>
#include <tny-folder-store.h>
#include <tny-folder-store-query.h>
#include <tny-send-queue.h>

#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"


%%
modulename tinymail
%%
ignore-glob
  *_get_type

%%
import gobject.GObject as PyGObject_Type
%%
override tny_folder_store_get_folders_async kwargs

static void
tny_get_folders_cb (TnyFolderStore *self, TnyList *list, GError **err, gpointer user_data)
{
    PyObject *callback, *args, *ret;
    PyGILState_STATE state;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)self),
			 pygobject_new((GObject *)list),
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();

    pyg_error_check(err);

    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF ((PyObject *)user_data);
    pyg_gil_state_release(state);
}


static PyObject *
_wrap_tny_folder_store_get_folders_async (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "list", "get_folders_func", "query", "user_data", NULL };
    PyObject *get_folders_func = Py_None, *user_data = Py_None;
    PyGObject *list = NULL, *query = NULL;
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|OO:TnyFolderStore.get_folders_async", kwlist,
                                     &list, &get_folders_func, &query, &user_data))
        return NULL;

    if (!PyCallable_Check(get_folders_func)) {
	PyErr_SetString(PyExc_TypeError, "get_folders_async must be callable");
	return NULL;
    }
  
    data = Py_BuildValue("(OO)", get_folders_func, user_data);

    tny_folder_store_get_folders_async (TNY_FOLDER_STORE (self->obj),
					TNY_LIST (list->obj),
				        tny_get_folders_cb, 
					query!=NULL?TNY_FOLDER_STORE_QUERY (query->obj):NULL, 
					data);
    return Py_None;
}
%%
override tny_folder_get_msg_async kwargs

static void
tny_get_msg_cb (TnyFolder *self, TnyHeader *header, TnyGetMsgCallback callback, gpointer user_data)
{
    PyObject *callback, *args, *ret;
    PyGILState_STATE state;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 1);
    args = Py_BuildValue("(NO)",
                         pygobject_new((GObject *)self),
                         PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
        PyErr_Print();

    pyg_error_check(err);
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF ((PyObject *)user_data);
    pyg_gil_state_release(state);
}

static PyObject *
_wrap_tny_folder_get_msg_async (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "header", "get_msg_func", "user_data", NULL };
    PyObject *get_msg_func, *user_data = Py_None;
    TnyHeader *header;
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:TnyFolder.get_msg_async",kwlist,
                                     &header, &get_msg_func, &user_data))
        return NULL;
    if (!PyCallable_Check(get_msg_func)) {
        PyErr_SetString(PyExc_TypeError, "get_msg_func must be callable");
        return NULL;
    }

    data = Py_BuildValue("(OOO)", header, get_msg_func, user_data);

    tny_folder_get_msg_async (TNY_FOLDER (self->obj), header,
                                      tny_get_msg_cb, data);
    return Py_None;
}

%%
override tny_folder_refresh_async kwargs

static void
tny_refresh_folder_cb (TnyFolder *self, gboolean cancelled, GError **err, gpointer user_data)
{
    PyObject *callback, *args, *ret;
    PyGILState_STATE state;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)self),
			 PyBool_FromLong (cancelled), 
			 PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();

    pyg_error_check(err);
	
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF ((PyObject *)user_data);
    pyg_gil_state_release(state);
}

static void
tny_refresh_folder_status_cb (TnyFolder *self, const gchar *what, gint status, gpointer user_data)
{
    PyObject *callback, *args, *ret;
    PyGILState_STATE state;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 1);
    args = Py_BuildValue("(NsiO)",
                         pygobject_new((GObject *)self),
			 what, status,
                         PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
        PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    pyg_gil_state_release(state);
}


static PyObject *
_wrap_tny_folder_refresh_async (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "refresh_func", "status_func", "user_data", NULL };
    PyObject *refresh_func, *status_func = Py_None, *user_data = Py_None;
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:TnyFolder.refresh_async",kwlist,
                                     &refresh_func, &status_func,
				     &user_data))
        return NULL;
    if (!PyCallable_Check(refresh_func)) {
	PyErr_SetString(PyExc_TypeError, "refresh_func must be callable");
	return NULL;
    }

    if (!PyCallable_Check(status_func)) {
	PyErr_SetString(PyExc_TypeError,"status_func must be callable");
	return NULL;
    }
  
    data = Py_BuildValue("(OOO)", refresh_func, status_func, user_data);

    tny_folder_refresh_async (TNY_FOLDER (self->obj),
				      tny_refresh_folder_cb, tny_refresh_folder_status_cb,
				      data);
    return Py_None;
}
%%
override-slot TnyList.tp_as_sequence

static int
_wrap_tny_list_tp_length(PyGObject *self)
{
    return tny_list_get_length(TNY_LIST(self->obj));
}

static PyObject *
_wrap_tny_list_tp_getitem(PyGObject *self, PyObject *key)
{
    GObject *ret = NULL;

    if (PyInt_Check (key)) {
        int index;
        TnyIterator *iter;

        index = PyInt_AsLong (key);
        if (index < 0)
            index += _wrap_tny_list_tp_length (self);

        iter = tny_list_create_iterator (TNY_LIST (self->obj));
        /* TODO: check for failure? */
		
	tny_iterator_nth (iter, index);
        ret = tny_iterator_get_current (iter);

        g_object_unref (G_OBJECT (ret)); /* IM Not sure about this one */
        g_object_unref (G_OBJECT (iter));
        
    } else {
        /* TODO: handle other keys */
	PyErr_SetString(PyExc_TypeError, "key must be valid index");
	return NULL;
    }

    return pygobject_new (ret);
}


static PySequenceMethods _wrap_tny_list_tp_as_sequence = {
    (inquiry) _wrap_tny_list_tp_length,
    (binaryfunc) NULL, /* concatenate (PyGObject, PyObject) -> new PyGObject */
    (intargfunc) NULL, /* repeat (PyGObject, int) ->new PyGObject */
    (intargfunc) _wrap_tny_list_tp_getitem,
    (intintargfunc) NULL, /* getslice (PyGObject, int, int) -> PyObject[tuple] */
    (intobjargproc) NULL, /* setitem (PyGObject, int, PyObject) -> int */
    (intintobjargproc) NULL, /* setslice (PyGObject, int, int, PyObject[tuple]) -> int */
    (objobjproc) NULL, /* contains (PyGObject, PyObject) -> int */
    (binaryfunc) NULL, /* sq_inplace_concat;*/
    (intargfunc) NULL /* sq_inplace_repeat */
};

